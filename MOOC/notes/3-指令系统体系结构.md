# 第三章 指令系统体系结构

## 3.1 设计自己的计算机

### 一个简单的计算机指令系统

运算类指令

ADD R, M：将R的内容与M中的内容相加后存入R

传送类指令

LOAD R,M：将M中的内容装入R
STORE M, R：将R的内容存入M中

转移类指令

JMP L：无条件转向L处

但是依然是汇编语句，不是二进制代码，此时需要规定指令的格式

### 指令的格式

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.05.54@2x.png" alt="CleanShot 2024-03-05 at 21.05.54@2x" style="zoom:30%;" />

每条指令等长，均为2个字节

第一个字节的高4位是操作码，目前只提供4条指令，最多可扩展到16条

- LOAD : 0000
- ADD : 0001
- STORE : 0010
- JMP : 0011

第一个字节的低4位是寄存器号，目前只提供4个寄存器，最多可扩展到16个

- RO~R3 : 0000~0011

第二个字节是存储单元地址，最大可以使用256个字节的存储器

### 运算任务示例

1. 将M1的内容与M2的内容相加后存入M3
2. 完成运算后，程序转向L处的指令继续执行

M1、M2、M3和L均为存储单元的地址

程序描述：

1. 将M1的内容送入某个寄存器，记为Rx
2. 将Rx的内容与M2的内容相加，运算结果存入Rx
3. 将Rx的内容送入M3中

### 运算任务对应的程序

iê : M1=5 , M2=6 , M3=7 , L=18

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.12.34@2x.png" alt="CleanShot 2024-03-05 at 21.12.34@2x" style="zoom:30%;" />

### 在存储器中的机器语言程序

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.12.59@2x.png" alt="CleanShot 2024-03-05 at 21.12.59@2x" style="zoom:30%;" />

###  模型机准备开始运行

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.15.41@2x.png" alt="CleanShot 2024-03-05 at 21.15.41@2x" style="zoom:30%;" />

当然最后还有一个问题，为什么PC寄存器当中的地址是这个呢？其实这是不一定的，这也是我们进行指令系统体系结构设计时。必须要约定的一个内容。

就是CPU在启动时，或者说在复位完成之后，第一条指令从哪里开始取出。

至于这个地址到底应该是什么，并没有明确的规则。

但通常情况下，我们会约定为这个体系结构所能访问的存储单元的最小地址，也就是0，或者是接近最高地址的地方。


## 3.2 x86体系结构

### x86体系结构

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.19.25@2x.png" alt="CleanShot 2024-03-05 at 21.19.25@2x" style="zoom:30%;" />

这张表列出来X86体系结构当中，具有代表性的一些微处理器的型号。先来看最早推出来的8086

### Intel 8086（1978年）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.21.38@2x.png" alt="CleanShot 2024-03-05 at 21.21.38@2x" style="zoom:30%;" />

8086的主要特点
① 内部的通用寄存器为16位，既能处理16位数据，也能处理8位数据
③ 对外有16根数据线和20根地址线，可寻址的内存空间为1MByte（220）
③ 物理地址的形成采用“段加偏移”的方式

### 微型计算机的早期代表：IBM PC

Intel 8088 CPU， 1979年推出。8088是8086的简化版本，主要区别是数据总线只有8位宽。

1981年，IBM PC 5150诞生

- 售价约1600美元
- Intel 8088 CPU，主频4.77MHz，内存16KB
- 因开放性架构逐渐成为个人计算机的制造标准

### Intel 80286（1982年）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.26.49@2x.png" alt="CleanShot 2024-03-05 at 21.26.49@2x" style="zoom:30%;" />

80286的主要特点

- 地址总线扩展到24位，可寻址16MB的内存空间
- 引入了“保护模式”，但是机制有缺陷
  - 例如，每个段仍为64KB，严重限制软件规模
- 为保持兼容，保留了8086的工作模式，被称为“实模式”

### 实模式（Real Mode）

实模式，又称“实地址模式”

- 80286及以上的微处理器采用8086的工作模式，即为 实模式
- 运行在实模式下的80x86微处理器像是一个更快的8086
- 为兼容8086，所有x86处理器在加电或复位后首先进入实模式
- 系统初始化程序在实模式下运行，为进入保护模式做好准备

### Intel 80386（1985年）

80386的主要特点

- 80x86系列中的第一款32位微处理器
- 支持32位的算术和逻辑运算，提供32位的通用寄存器
- 地址总线扩展到32位，可寻址4GB的内存空间
- 改进了“保护模式”（例如，段范围可达4GB）
- 增加了“虚拟8086模式"，可以同时模拟多个8086微处理器

### 保护模式（Protected Mode）

保护模式，可简写为“pmode”

- 80386及以上的微处理器的主要工作模式
- 支持多任务
- 支持设置特权级
- 支持特权指令的执行
- 支持访问权限检查
- 可以访问4GB的物理存储空间
- 引入了虛拟存储器的概念

保护模式让操作系统加强了对应用软件的控制，使得系统运行更安全高效

### 三种工作模式之间的转换

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.31.17@2x.png" alt="CleanShot 2024-03-05 at 21.31.17@2x" style="zoom:30%;" />

实模式：从加电启动或复位到操作系统运行之前

保护模式：操作系统和应用程序的运行

虚拟8086模式：运行兼容8086程序

注：PE即“保护模式允许”，是80x86控制寄存器CRO中的控制位

注：Intel提出的IA-64是独立于x86的一种新的体系结构，不兼容IA-32

### AMD Opteron ( 2003年）

Opteron
主频1.4~3.5GHz
工艺130~32nm

Opteron的主要特点

-  ×86扩展到64位的第一款微处理器
- 可以访问高于4GB的存储器
- 兼容32位x86程序，且不降低性能

### Intel Italium

不是x86-64，是IA-64体系结构

是64位，不兼容32位程序，使用可以运行32位程序的模式会导致32位程序性能大大下降

### x86-64的运行模式

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.56.56@2x.png" alt="CleanShot 2024-03-05 at 21.56.56@2x" style="zoom:30%;" />

### 从16位到64位：x86体系结构的演变

#### 寄存器模型

##### IA16，x86-16

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 21.59.04@2x.png" alt="CleanShot 2024-03-05 at 21.59.04@2x" style="zoom:30%;" />

1. 通用寄存器（多功能寄存器）

数据寄存器，共有4个
。均为16位寄存器
。每个16位寄存器都可分为两个8位寄存器使用
。适用大多数算术运算和逻辑运算指令
。除存放通用数据外，各有一些专门的用途：

AX Accumulator 存放乘除等指令的操作数
BX Base 存放存储单元的偏移地址
CX Count 存放计数值
DX Data 除法运算的部分被除数，乘法运算产生的部分积



指针和变址寄存器，共有4个，分为两组
。均为16位寄存器
。SP和BP用于堆栈操作
。SI和DI用于串操作
。都可以作为数据寄存器使用

SP stack pointer 堆栈指针寄存器
BP (stack)base pointer （堆栈）基址指针寄存器
SI source index 源变址寄存器
DI destination index 目的变址寄存器



段寄存器

CS 代码段寄存器（Code Segment）
DS 数据段寄存器（Data Segment）
ES 附加段寄存器（Extra Segment）
SS 堆栈段寄存器（Stack Segment）

2. 标志寄存器

标志位
。 FLAGS寄存器中包含若干标志位
。标志位分为两大类：状态标志和控制标志

状态标志 反映CPU的工作状态
例如：
。执行加法运算时是否产生进位
。运算结果是否为零

控制标志 对CPU的运行起特定控制作用
例如：
。以单步方式还是连续方式运行
。是否允许响应外部中断请求

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.07.35@2x.png" alt="CleanShot 2024-03-05 at 22.07.35@2x" style="zoom:30%;" />

##### IA-32

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.08.12@2x.png" alt="CleanShot 2024-03-05 at 22.08.12@2x" style="zoom:30%;" />

##### x86-64

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.09.32@2x.png" alt="CleanShot 2024-03-05 at 22.09.32@2x" style="zoom:30%;" />

#### 存储器寻址

##### IA16，x86-16

指令指针寄存器 IP（Instruction Pointer）
。保存一个内存地址，指向当前需要取出的指令
。当CPU从内存中取出一个指令后，IP会自动增加，指向下一指令的地址（注：实际情况会复杂的多）
。程序员不能直接对IP进行存取操作
。转移指令、过程调用/返回指令等会改变IP的内容

IP寄存器的寻址能力：
2^16=65536（64K）字节单元

8086对外有20位地址线
寻址范围：2^20=1M字节单元

8086的段寄存器解决IP寄存器寻址能力不足的问题



##### 段寄存器（Segment Register）
。与其它寄存器联合生成存储器地址

CS 代码段寄存器（Code Segment）
DS 数据段寄存器（Data Segment）
ES 附加段寄存器（Extra Segment）
SS 堆栈段寄存器（Stack Segment）



##### 8086的物理地址生成

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.16.42@2x.png" alt="CleanShot 2024-03-05 at 22.16.42@2x" style="zoom:30%;" />



##### 逻辑段在物理存储器中的位置

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.18.07@2x.png" alt="CleanShot 2024-03-05 at 22.18.07@2x" style="zoom:30%;" />

1M字节的存储空间分成许多逻辑段，每段最长64K字节，可以用16位地址进行寻址

将物理地址看作逻辑地址，分成两个部分，好处是：不需要知道代码或数据在存储器中的具体物理位置，从而简化存储资源的管理，**<u>比如将代码所需的数据在内存中存储的位置改变，只需要改变段寄存器即可</u>**

各个逻辑段在实际存储空间中可以完全分开，也可以部分重叠，甚至完全重叠

##### "段加偏移”的编程实例

汇编指令 MOV AX，［3000H］

操作数默认存放在DS指向的数据段中，即[3000H]=DS:[3000H]

设：DS=2000H，则：物理地址=2000H× 16+3000H=23000H

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.21.52@2x.png" alt="CleanShot 2024-03-05 at 22.21.52@2x" style="zoom:30%;" />

##### 1964年，大型计算机的经典：IBM S/360

IBM S/360

• IBM公司1964年研制。每秒执行34000条指令，注重通用性和兼容性
•第一代大型机中最成功的产品。1966年售出超过八干台。

##### IA-32的存储器寻址

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 22.37.57@2x.png" alt="CleanShot 2024-03-05 at 22.37.57@2x" style="zoom:30%;" />

以指令的寻址为例
实模式 CS:IP
保护模式 CS:EIP

EIP寄存器的寻址能力：232=4G字节单元
80386对外有32位地址线，寻址范围：232=4G字节单元

但是其实保护模式下，段基址不在CS中，而是在内存中，这个段基址被称作描述符

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 23.26.12@2x.png" alt="CleanShot 2024-03-05 at 23.26.12@2x" style="zoom:30%;" />

GDT：全局描述符表
GDTR：全局描述符表的地址寄存器
GDT可在系统中的任何存储单元，通过GDTR定位

GDTR + CS即可

##### x86-64的描述符

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 23.29.06@2x.png" alt="CleanShot 2024-03-05 at 23.29.06@2x" style="zoom:30%;" />

注：描述符中没有了段基址和段界限，只有访问权限字节和若干控制位。所有的代码段都从地址0开始。

## 3.3 x86指令简介

### 指令的主要类别

运算类指令
例如：加、減、乘、除，与、或、非等

传送类指令
例如：从存储器到通用寄存器，从通用寄存器到1/O接口等

转移类指令
例如：无条件转移、条件转移、过程调用等

控制类指令
例如：暂停处理器、清除标志位等

### 指令的运行结果

改变通用寄存器的内容
如 ADD AX, DX

改变存储器单元的内容
如MOV [10H], CX

改变标志位
*如产生进位

改变指令指针
**N JMP [BX]

改变外设端口的内容
*如访问显示端口

### 指令分类举例

#### 传送指令

作用：把数据或地址传送到寄存器或存储器单元中

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 23.40.27@2x.png" alt="CleanShot 2024-03-05 at 23.40.27@2x" style="zoom:30%;" />

##### MOV指令（传送）

格式：MOV DST,SRC
操作：DSTSRC
说明：
。DST表示目的操作数，SRC表示源操作数
。MOV指令把一个操作数从源传送至目的，源操作数保持不变



###### MOV指令和寻址方式的示例

MOV EBX, 40
MOV AL, BL
MOV ECX, [1000H]
MOV [DI], AX
MOV WORD PTRIBX+SI*2+200H], 01H
注：BYTE PTR：字节长度标记
WORD PTR：字长度标记
DWORD PTR：双字长度标记



###### 不同类型的MOV指令编码

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 23.46.37@2x.png" alt="CleanShot 2024-03-05 at 23.46.37@2x" style="zoom:30%;" />

CPU怎么知道变长指令集每个指令多长？

根据第一个字节判断即可

###### MOV指令编码示例

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-05 at 23.50.41@2x.png" alt="CleanShot 2024-03-05 at 23.50.41@2x" style="zoom:30%;" />

##### PUSH指令（压栈）

格式：PUSH SRC
说明：
。SRC表示寄存器操作数或存储器操作数

##### POP指令（弹栈）

格式：POP DST
说明：
。 DST表示寄存器操作数或存储器操作数
。 DST也可以是除CS寄存器以外的段寄存器

##### PUSH和POP指令操作示意

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.02.00@2x.png" alt="CleanShot 2024-03-06 at 00.02.00@2x" style="zoom:30%;" />

注：堆栈结构是所谓“向下生长”，即栈底在堆栈的高地址端。而堆栈段的段基址（由SS寄存器确定）并不是栈底。

#### 算术运算指令

作用
。完成加、減、乘、除等算术运算
。提供运算结果调整、符号扩展等功能

操作数的限制
。目的操作数不能是立即数或CS寄存器
。两个操作数不能同时为存储器操作数

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.03.42@2x.png" alt="CleanShot 2024-03-06 at 00.03.42@2x" style="zoom:30%;" />

##### 加法类指令

ADD指令（加）
◎ 格式：ADD DST, SRC
◎ 操作：DST DST+SRC
ADC指令（带进位的加）
◎格式：ADC DST, SRC
• 171F : DST-DST+SRC+CF
INC指令（加1）
◎ 格式：INC OPR
◎ 操作：OPR OPR+1

INC Reg
指令长度为1字节

##### 减法类指令

SUB指令（减）
◎ 格式：SUB DST, SRC
© 操作：DST DST-SRC
SBB指令（带借位的减）
◎ 格式：SBB DST, SRC
• 11F : DST-DST-SRC-CF
DEC指令（减1）
◎ 格式：DEC OPR
◎ 操作：OPR OPR-1

CMP指令（比较）
◎ 格式：CMP DST, SRC
◎ 操作：DST-SRC
◎ 说明：減法操作，但不回写结果，仅影响标志位

#### 逻辑运算和移位指令

作用
。实现对二进制位的操作和控制
。又称“位操作指令”操作数的限制
。对于单操作数指令，操作数不能是立即数
。对于双操作数指令，限制与MOV指令相同

##### NOT指令（逻辑非）

MOV AL, 10101010B
NOT AL
;now: AL=01010101B

格式：NOT OPR
操作：OPR按位求反，送回OPR

##### AND指令（逻辑与）

MOV BL, 11111010B
AND BL, OFH
; now: BL=00001010B

格式：AND DST, SRC
操作：将DST和SRC的内容按位进行“与”操作，结果
送到DST中

##### SHL指令（左移）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.15.41@2x.png" alt="CleanShot 2024-03-06 at 00.15.41@2x" style="zoom:30%;" />

格式：SHL DST,CNT，最后一位移出的在CF寄存器中

操作：
。将DST的内容按图中方式移动
。移动位数由CNT指定
说明：
。DST可以是寄存器或存储器操作数
。CNT可以是立即数1或CL寄存器
。相当于无符号数乘以2n的运算

示例：设AL中有一个无符号数X，用移位指令求10X
MOV АН, 0
SHL AX,1；得到2X
MOV BX, AX
MOV CL, 2
SHL AX，CL；得到8X
ADD AX,BX；得到10x

##### SHR指令（逻辑右移）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.22.46@2x.png" alt="CleanShot 2024-03-06 at 00.22.46@2x" style="zoom:30%;" />

格式：SHR DST, CNT
说明：相当于无符号数除以20的运算

##### SAR指令（算术右移）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.22.55@2x.png" alt="CleanShot 2024-03-06 at 00.22.55@2x" style="zoom:30%;" />

格式：SAR DST, CNT
说明：相当于带符号数除以20的运算

#### 转移指令

作用
。改变指令执行顺序
说明
。根据是否有判断条件，分为无条件转移指令和条件转移指令两大类
。根据转移目标地址的提供方式，可分为直接转移和间接转移两种方式

##### 无条件转移指令 - 直接转移（直接给出下一个IP）

短转移：JMP SHORT LABEL
。操作：IP -IP+8位的位移量（-128~127Byte）
近转移：JMP NEAR PTR LABEL
。操作：IP--IP+16位的位移量（士32KByte）
远转移：JMP FAR PTR LABEL（一般是转移到不同的代码段，也称作段间转移）
。操作：IP<LABEL的偏移地址；CS LABEL的段基址

1. 位移量是一个带符号数，为LABEL的偏移地址与当前EIP/IP值之差
2. 从80386开始，近转移可以使用32位的位移量

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.27.07@2x.png" alt="CleanShot 2024-03-06 at 00.27.07@2x" style="zoom:30%;" />

远转移例子：

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.30.22@2x.png" alt="CleanShot 2024-03-06 at 00.30.22@2x" style="zoom:30%;" />

接下来CPU就会从 [43006H] 开始执行

##### 无条件转移指令- 间接转移（给出下一个IP存放的位置，而不是直接给出下一个IP）

转移目标地址在寄存器中
• JMP AX ; AX → IP
• JMP EAX ; EAX → EIP

转移目标地址在存储器中
• JMP [SI] ; [SI] → IP
• JMP FAR PTR[SI] ; [SI] → IP, [SI+2] → CS

##### 条件转移指令

操作
。根据当前的状态标志位决定是否发生转移

说明
。一般在影响标志位的算术或逻辑运算指令之后
。8086中，所有的条件转移都是短转移
•同一代码段内，-128~127字节范围内
。从80386起，条件转移指令可以使用32位的长位移量
•同一代码段内，±2G字节范围

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.40.43@2x.png" alt="CleanShot 2024-03-06 at 00.40.43@2x" style="zoom:30%;" />

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.41.05@2x.png" alt="CleanShot 2024-03-06 at 00.41.05@2x" style="zoom:30%;" />

程序示例

计算存储器中［2000H] 和［3000H］起始的两个数之和，数的长度存放在［2500H］字节单元

```assembly
MOV CL, [2500H] ;
MOV SI, 2000H
MOV DI, 3000H
CLC ；将标志位CF清零
LOOP1: MOV AX, [SI]
ADC AX, [DI]
MOV [SI], AX
INC SI
INC SI ;可否使用“ADD SI, 2"？不可以，防止影响CL寄存器，INC指令不更新CL寄存器
INC DI
INC DI
DEC CL
JNZ LOOP1 ;循环执行［2500］次
MOV AX, OH
ADC AX, ОН
& MOV [SI], AX
```

#### 处理器控制指令

作用
。控制CPU的功能
。对标志位进行操作

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 00.53.29@2x.png" alt="CleanShot 2024-03-06 at 00.53.29@2x" style="zoom:30%;" />

NOP的作用：

**代码对齐：** 在某些处理器架构中，特定的指令序列如果能够在内存中对齐到特定的边界，比如4字节或16字节边界，可能会更高效地被执行。使用`NOP`指令可以填充空间，帮助实现这种对齐，进而优化程序的执行速度。

**延时：** 在一些对时序敏感的硬件操作中，可能需要在两个操作之间简单地延迟一段时间。通过插入一定数量的`NOP`指令，可以实现微小的延时。

**占位符：** 在开发阶段，`NOP`可以作为暂时的占位符使用，例如在还未实现的功能位置上。这使得程序员可以先构建起程序的框架，之后再回来填充具体的实现代码。

**调试和测试：** 在调试过程中，可能需要暂时移除或替换某些指令，而不改变代码的总长度。`NOP`指令可以用来替换那些需要被暂时忽略的指令，而不影响程序的其他部分。

**绕过某些限制：** 在某些特定的情况下，比如跳过硬件缺陷引起的问题，或者在不改变程序流的情况下绕过某些安全检查，`NOP`指令可能被用来填充必要的空间。

## 3.4 复杂的x86指令举例

### 串操作指令

作用
。对存储器中的数据串进行每次一个元素的操作
。串的基本单位是字节或字（即“一个元素”）
。串长度可达64KB

分类
。共5条串操作指令
。另有3种重复前缀，与串操作指令配合使用

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.07.09@2x.png" alt="CleanShot 2024-03-06 at 01.07.09@2x" style="zoom:30%;" />

#### 介绍一个：MOVSB指令（字节串传送）

格式：MOVSB
操作：在存储器中将指定位置的一个字节单元传送到另一个指定的位置

#### 与其配合的重复前缀为：REP前缀（无条件重复）

格式：REP 串操作指令
操作：当CX != 0时，重复执行串操作指令

#### MOVSB 指令是没有操作数的，不是因为它很简单，是因为操作数太多了写不下

隐含操作数
。源串地址为DS:SI，目的串地址为ES:DI
。串的长度在CX寄存器中

处理完一个串元素后的操作（硬件自动完成）
① 修改SI和DI，指向下一个串元素
② 若使用重复前缀，则CX = CX-1

#### MOVSB举例

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.13.13@2x.png" alt="CleanShot 2024-03-06 at 01.13.13@2x" style="zoom:30%;" />

前两行汇编代码不合并是因为段寄存器之间不能互相传送

#### 串传送方向（标志寄存器中的DF标志位）

设置DF=0
。从“源串”的低地址开始传送
。传送过程中，SI和DI自动增量修改
设置DF=1
。从“源串”的高地址开始传送
。传送过程中，SI和DI自动减量修改

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.16.51@2x.png" alt="CleanShot 2024-03-06 at 01.16.51@2x" style="zoom:30%;" />

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.17.18@2x.png" alt="CleanShot 2024-03-06 at 01.17.18@2x" style="zoom:30%;" />

#### 方向标志的作用

应对“源串”和“目的串”的存储区域部分重叠的问题

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.18.04@2x.png" alt="CleanShot 2024-03-06 at 01.18.04@2x" style="zoom:30%;" />

### 循环控制指令

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.19.29@2x.png" alt="CleanShot 2024-03-06 at 01.19.29@2x" style="zoom:30%;" />

LOOPNE/LOOPNZ指令（不为零/不相等时循环）

格式：LOOPNE LABEL
或者 LOOPNZ LABEL

操作

- CX←СХ-1
- 若CX≠0且ZF=0，转移到LABEL处继续执行，否则，结束循环，顺序执行下一条指令



#### 循环控制指令示例

在100个字符的字符串中寻找第一个$字符

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.22.49@2x.png" alt="CleanShot 2024-03-06 at 01.22.49@2x" style="zoom:30%;" />

### 查表指令

XLAT指令（换码，查表）

格式：XLAT
操作：
（事先在数据段中定义了一个字节型数据表）
① 从BX中取得数据表起始地址的偏移量
② 从AL中取得数据表项索引值
③ 在数据表中查得表项内容
④ 将查得的表项内容存入AL

#### XLAT指令示例

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.24.51@2x.png" alt="CleanShot 2024-03-06 at 01.24.51@2x" style="zoom:30%;" />

### 十进制调整指令

DAA指令（加法十进制调整指令）

格式：DAA
操作：
。跟在二进制加法指令之后
。将AL中的“和” 数调整为压缩BCD数格式
。调整结果送回AL

#### BCD (Binary-Coded Decimal )

BCD数具有二进制编码的形式，又保持了十进制的特点，可以作为人与计算机联系时的中间表示

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.26.28@2x.png" alt="CleanShot 2024-03-06 at 01.26.28@2x" style="zoom:30%;" />

用处：计算十进制运算同时避免进制转换

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.29.40@2x.png" alt="CleanShot 2024-03-06 at 01.29.40@2x" style="zoom:30%;" />

### “最长的指令”

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.30.58@2x.png" alt="CleanShot 2024-03-06 at 01.30.58@2x" style="zoom:30%;" />

x86指令的复杂程度由此可见一斑

## 3.5 MIPS体系结构

### MIPS的设计者和 RISC的先驱

约翰•亨尼西
John Hennessy
1953年出生

。1977年，进入斯坦福大学任职
1981年，领导RISC微处理器的研究小组
1984年，共同创立MIPS计算机系统公司
。1989年~1999年，先后担任斯坦福大学计算机系统实验室主任、计算机系主任和工程学院院长等
。2000年起，任斯坦福大学校长

RISC:Reduced Instruction Set Computer，精简指令系统计算机
CISC:Complex Instruction Set Computer，复杂指令系统计算机

### MIPS公司的商业兴衰

1984年，MIPS计算机系统公司成立
1988年，SGI公司在其计算机产品中采用MIPS处理器
1989年，MIPS第一次上市
1992年，SGI收购MIPS，更名为MIPS技术公司
1998年，MIPS再次上市
2012年，Imagination Technologies收购MIPS
MIPS处理器广泛应用的领域：
。数字电视、机顶盒、蓝光播放器、游戏机、网络设备等

### MIPS的设计指导思想

MIPS的全称
Microprocessor without Interlocked Piped Stages
主要关注点
。減少指令的类型
。降低指令复杂度
基本原则
• A simpler CPU is a faster CPU.

### MIPS指令的主要特点

固定的指令长度（32-bit ，即1 word）
。简化了从存储器取指令
简单的寻址模式
。简化了从存储器取操作数
指令数量少，指令功能简单（一条指令只完成一个操作）
。简化指令的执行过程
只有Load和Store指令可以访问存储器
。例如，不支持x86指令的这种操作：ADD AX，［3000H］
需要优秀的编译器支持

### MIPS指令示例（运算指令）

#### 加法指令

格式: add a, b, c
操作：将b和c求和，结果存入a中

add a, b, c
sub a, b, c
mul a, b, c
div a, b, c

and a, b, c
or a, b, c

sll a, b, C
srl a, b, C

### MIPS指令示例（访存指令）

假设
。A是一个100个字（word）的数组，首地址在寄存器\$19中
。变量h对应寄存器\$18
。临时数据存放在寄存器\$8

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.41.22@2x.png" alt="CleanShot 2024-03-06 at 01.41.22@2x" style="zoom:30%;" />

### MIPS的通用寄存器

MIPS的通用寄存器（32个，每个都是32位宽）

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.41.36@2x.png" alt="CleanShot 2024-03-06 at 01.41.36@2x" style="zoom:30%;" />

### 通用寄存器使用示例

以下指令与对应注释中的指令相同

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.43.28@2x.png" alt="CleanShot 2024-03-06 at 01.43.28@2x" style="zoom:30%;" />

## 3.6 MIPS指令简介

### MIPS指令

R:Register，寄存器
1:Immediate，立即数
J：Jump，无条件转移

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.45.37@2x.png" alt="CleanShot 2024-03-06 at 01.45.37@2x" style="zoom:30%;" />

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 01.47.28@2x.png" alt="CleanShot 2024-03-06 at 01.47.28@2x" style="zoom:30%;" />

### R型指令的格式

R型指令格式包含6个域
。2个6-bit域，可表示0~63的数
。4个5-bit城，可表示0~31的数

Funct用于指定指令的类型。对于所有R型指令，该域的值均为0

与opcode域组合，精确地指定指令的类型

为什么不合并？

**指令解码复杂度增加**：合并后，CPU的指令解码逻辑变得更加复杂。因为现在每条指令的标识都是独一无二的12-bit标识符，CPU需要通过更复杂的逻辑来识别和执行指令，这可能会影响指令的解码速度。

**指令集扩展性降低**：在`opcode`和`funct`分开的设计中，通过改变`funct`值来增加新的操作是相对容易的，因为它不需要调整或重定义`opcode`值。如果将它们合并，每增加一条新指令可能都需要重新考虑整个指令集的布局，这限制了指令集的灵活性和未来的扩展性。

**编码空间的浪费**：虽然12-bit提供了更多的编码空间（4096种可能的值），但实际上，并非所有的组合都会被用到。这可能会导致编码空间的浪费，因为某些特定的组合可能永远不会被实现为有效指令。

**可读性和编程便利性降低**：对于汇编语言程序员而言，分开的`opcode`和`funct`字段让指令的功能更加明显，易于理解和记忆。合并这两个字段可能会使得指令看起来更加抽象，增加编程的难度。

rs Source Register
。通常用于指定第一个源操作数所在的寄存器编号
rt Target Register
。通常用于指定第二个源操作数所在的寄存器编号
rd Destination Register
。通常用于指定目的操作数（保存运算结果）的寄存器编号
5-bit的域可表示0~31，对应32个通用寄存器

shamt shift amount
。用于指定移位指令进行移位操作的位数
。5-bit的域可表示0~31，对于32-bit数，更多移位没有实际意义
。对于非移位指令，该域设为0

### R型指令的编码示例

add $8,59,910
。查指令编码表得到：
opcode =0,funct = 32， shamt =0（非移位指令）
。根据指令操作数得到：
rd =8（目的操作数），rs=9（第一个源操作数）rt = 10（第二个源操作数）

### I型指令的格式

opcode
。用于指定指令的操作类型（但没有funct域）
rs Source Register
。指定第一个源操作数所在的寄存器编号
rt Target Register
。指定用于目的操作数（保存运算结果）的寄存器编号
。对于某些指令，指定第二个源操作数所在的寄存器编号

immediate
。16-bit的立即数，可以表示216个不同数值
。对于访存指令，如Iw rt,imm（rs）
通常可以满足访存地址偏移量的需求（-32768~+32767）
。对于运算指令，如addi rt, rs, imm
无法满足全部需求，但大多数时候可以满足需求

### I型指令的编码示例

addi $21,$22,-50 $21=$22+ (-50)
。查指令编码表得到：
opcode = 8
。分析指令得到：
rs = 22（源操作数寄存器编号）
rt = 21（目的操作数寄存器编号）
immediate =-50（立即数）

### 分支指令的分类

Branch
。分支：改变控制流

Conditional Branch
。条件分支：根据比较的结果改变控制流
• 两条指令 : branch if equal (beg) ; branch if not equal (bne)

Unconditional Branch
。非条件分支：无条件地改变控制流
。一条指令：jump （j）

### 条件分支指令（I型）

条件分支
• beq rs, rt, imm # opcode=4
• bne rs, rt, imm # opcode=5

格式：beq regl,reg2, L1
if (value in reg1) ==(value in reg2)
goto Ll

注意没有标志寄存器

### 条件分支指令的示例

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 02.00.15@2x.png" alt="CleanShot 2024-03-06 at 02.00.15@2x" style="zoom:30%;" />

### 条件分支指令的目标地址范围

如何充分发挥16-bit的作用？

。以当前PC为基准，16-bit位移量可以表示2^15 bytes

。 MIPS的指令长度固定为32-bit（word）

。16-bit位移量可以表示 215words = ±217 bytes（±128KB）：单位从字节变为MIPS指令个数

目标地址计算方法：
。分支条件不成立，PC = PC + 4 = next instruction
。分支条件成立；PC= （PC+4）+（immediate*4）

### 非条件分支指令（J型）

在不需要条件判断的情况下，如何扩大目标地址范围
。理想情况，直接使用32-bit地址
。冲突：MIPS的指令长度固定为32-bit,opcode占用了6-bit
目标地址计算方法：
• New PC ={ (PC+4) [31..28], address, 00}

可以达到28位的跳转范围

### 两种分支指令示例

<img src="./3.指令系统体系结构.assets/CleanShot 2024-03-06 at 02.05.40@2x.png" alt="CleanShot 2024-03-06 at 02.05.40@2x" style="zoom:30%;" />

### 非条件分支指令（R型）

J型指令的目标地址范围： 228bytes（ 256MB）
如何到达更远的目标地址
。2次调用j指令
。使用jr指令：jr rs