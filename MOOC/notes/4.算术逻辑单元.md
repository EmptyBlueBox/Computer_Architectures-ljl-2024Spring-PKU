# 第四章 算术逻辑单元



## 4.1 算术运算和逻辑运算

### 加法指令的编码示例（1）

C语言程序
int f, g, h;
f = g + h;

add \$8 \$9 \$10

。查指令编码表得到：
opcode = 0，funct = 20hex，shamt = 0（非移位指令）

。根据指令操作数得到：
rd = 8（目的操作数），rs=9（第一个源操作数），rt = 10（第二个源操作数）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.16.21@2x.png" alt="CleanShot 2024-03-18 at 22.16.21@2x" style="zoom:50%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.16.56@2x.png" alt="CleanShot 2024-03-18 at 22.16.56@2x" style="zoom:50%;" />

#### 加法运算示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.26.42@2x.png" alt="CleanShot 2024-03-18 at 22.26.42@2x" style="zoom:30%;" />

### 加法指令的编码示例（2）

addi $21,$22,-50 # \$21=\$22+ (-50)

。查指令编码表得到：
opcode = 8

。分析指令得到：
rs = 22（源操作数寄存器编号）
rt =21（目的操作数寄存器编号）
immediate =-50（立即数）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.29.36@2x.png" alt="CleanShot 2024-03-18 at 22.29.36@2x" style="zoom:50%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.29.55@2x.png" alt="CleanShot 2024-03-18 at 22.29.55@2x" style="zoom:50%;" />

#### 加法运算示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.31.44@2x.png" alt="CleanShot 2024-03-18 at 22.31.44@2x" style="zoom:30%;" />

### 逻辑“与”指令的编码示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.54.49@2x.png" alt="CleanShot 2024-03-18 at 22.54.49@2x" style="zoom:30%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.55.10@2x.png" alt="CleanShot 2024-03-18 at 22.55.10@2x" style="zoom:30%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-18 at 22.55.43@2x.png" alt="CleanShot 2024-03-18 at 22.55.43@2x" style="zoom:30%;" />

### 算术运算指令（MIPS Core Instruction Set）：

#### R型

add rd, rs, rt # R[rd]=R[rs]+R[rt]       (1)
addu rd, rs, rt # R[rd]=R[rs]+R[rt]
sub rd,rs, rt # R[rd]=R[rs] -R[rt]       (1)
subu rd, rs, rt # R[rd]=R[rs]-R[rt]

#### I型

addi rt, rs, imm # R[rt]=R[rs]+SignExt Imm        (1, 2)

addiu rt, rs, imm # R[rt]=R[rs] +SignExt Imm (2)





(1) May cause overflow exception
(2) SignExtImm={ 16{imm[15]}, imm }

### 逻辑运算指令（MIPS Core Instruction Set）

#### R型

and rd, rs, rt # R[rd]=R[rs]&R[rt]
or rd, rs, rt #Rlrd］=RIES］IRIrt］
nor rd, rs, rt # R[rd]=~ (R[rs] |R[rt] )

#### I型

andi rt, rs, imm # R[rt]=R[rs]&ZeroExt Imm (3)
ori rt, rs, imm # R[rt]=R[rs] |ZeroExt Imm (3)



(3) ZeroExtImm=( 16{1'b0}, imm }

### 算术逻辑运算的需求

#### 算术运算

两个32-bit数的加法，结果为一个32-bit数

两个32-bit数的減法，结果为一个32-bit数

检查加減法的结果是否溢出

#### 逻辑运算

两个32-bit数的“与”操作，结果为一个32-bit数

两个32-bit数的“或”操作，结果为一个32-bit数

两个32-bi数的“或非”操作，结果为一个32-bit数

## 4.2 门电路的基本原理

### 晶体管（transistor）

现代集成电路中通常使用MOS晶体管（Metal-Oxide-Semiconductor：金属-氧化物-半导体）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 00.57.16@2x.png" alt="CleanShot 2024-03-19 at 00.57.16@2x" style="zoom:30%;" />

Gate连接高电平的时候N型MOS导通

### 非门 ( NOT gate )

逻辑符号

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.00.04@2x.png" alt="CleanShot 2024-03-19 at 01.00.04@2x" style="zoom:30%;" />

真值表

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.00.32@2x.png" alt="CleanShot 2024-03-19 at 01.00.32@2x" style="zoom:30%;" />

逻辑函数表示 Y=A (Y=~A, Y=!A )

非门原理图

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.01.02@2x.png" alt="CleanShot 2024-03-19 at 01.01.02@2x" style="zoom:30%;" />

#### 非门的工作过程示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.02.28@2x.png" alt="CleanShot 2024-03-19 at 01.02.28@2x" style="zoom:30%;" />

### 与门（AND gate）

逻辑符号

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.04.57@2x.png" alt="CleanShot 2024-03-19 at 01.04.57@2x" style="zoom:30%;" />

真值表

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.05.14@2x.png" alt="CleanShot 2024-03-19 at 01.05.14@2x" style="zoom:50%;" />

逻辑函数表示 Y=A•B

与非门原理图

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.05.39@2x.png" alt="CleanShot 2024-03-19 at 01.05.39@2x" style="zoom:30%;" />

实际用“与非门”和“非门”实现“与门”

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.05.52@2x.png" alt="CleanShot 2024-03-19 at 01.05.52@2x" style="zoom:30%;" />

#### 与非门的工作过程示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.20.18@2x.png" alt="CleanShot 2024-03-19 at 01.20.18@2x" style="zoom:30%;" />

### 或门（OR gate）

逻辑符号

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.20.59@2x.png" alt="CleanShot 2024-03-19 at 01.20.59@2x" style="zoom:30%;" />

逻辑函数表示 Y=A+B

真值表

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.21.24@2x.png" alt="CleanShot 2024-03-19 at 01.21.24@2x" style="zoom:30%;" />

### 异或门（Exclusive-OR gate, XOR gate）

异或运算：A^B=（~A•B）+（A•~B）

两个值不相同，则异或结果为真。反之，为假。

逻辑符号

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.22.30@2x.png" alt="CleanShot 2024-03-19 at 01.22.30@2x" style="zoom:30%;" />

逻辑函数表示 Y=A^B

真值表

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.22.51@2x.png" alt="CleanShot 2024-03-19 at 01.22.51@2x" style="zoom:30%;" />

### 晶体管、逻辑门

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.23.36@2x.png" alt="CleanShot 2024-03-19 at 01.23.36@2x" style="zoom:30%;" />

## 4.3 寄存器的基本原理

### 寄存器的内部结构

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.27.40@2x.png" alt="CleanShot 2024-03-19 at 01.27.40@2x" style="zoom:30%;" />

### D触发器（D flip-flop, DFF）

D触发器

- 具有存储信息能力的基本单元
- 由若干逻辑门构成，有多种实现方式
- 主要有一个数据输入、一个数据输出和一个时钟输入
- 在时钟clock的上升沿（0-1），采样输入D的值，传送到输出Q，其余时间输出Q的值不变

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.29.15@2x.png" alt="CleanShot 2024-03-19 at 01.29.15@2x" style="zoom:30%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.32.58@2x.png" alt="CleanShot 2024-03-19 at 01.32.58@2x" style="zoom:30%;" />

clock两个上升沿之间的时间就是时钟周期

### D触发器的工作原理

照相机+显示器 一D触发器
每10秒钟按一次快门一时钟频率为0.1Hz
按快门后1秒钟，显示器上显示照片 一CLK-to-Q时间为1秒
按快门前后，待拍摄的画面不能有变化—Setup/Hold时间

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.30.40@2x.png" alt="CleanShot 2024-03-19 at 01.30.40@2x" style="zoom:30%;" />

DFF要求在时钟上升的时候输入不能变化，否则采样可能出现错误，也就是setup-hold时间之内，输入不能变

### 寄存器的构成

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.34.45@2x.png" alt="CleanShot 2024-03-19 at 01.34.45@2x" style="zoom:30%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.35.09@2x.png" alt="CleanShot 2024-03-19 at 01.35.09@2x" style="zoom:30%;" />

注：这只是一个简单的原理性说明，现实中寄存器的实现要复杂的多

## 4.4 逻辑运算的实现

### 与门 和 与运算指令

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.49.34@2x.png" alt="CleanShot 2024-03-19 at 01.49.34@2x" style="zoom:30%;" />

### 与运算的实现

and rd, rs, rt

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.50.28@2x.png" alt="CleanShot 2024-03-19 at 01.50.28@2x" style="zoom:30%;" />

### 或运算的实现

or ra, rs, it

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.50.56@2x.png" alt="CleanShot 2024-03-19 at 01.50.56@2x" style="zoom:30%;" />

### 包含多种功能的运算单元

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.52.36@2x.png" alt="CleanShot 2024-03-19 at 01.52.36@2x" style="zoom:30%;" />

### 逻辑运算示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.53.16@2x.png" alt="CleanShot 2024-03-19 at 01.53.16@2x" style="zoom:30%;" />

## 4.5 加法和减法的实现

### 二进制的加法

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.55.24@2x.png" alt="CleanShot 2024-03-19 at 01.55.24@2x" style="zoom:30%;" />

### 半加器（Half Adder）

半加器的功能是将两个一位二进制数相加

- 输入端口A、B
- 输出端口S（和）、C（进位）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 01.57.11@2x.png" alt="CleanShot 2024-03-19 at 01.57.11@2x" style="zoom:30%;" />

### 全加器（Full Adder）

全加器由两个半加器构成

- 输入端口A、B、Cin（进位输入）
- 输出端口S（和）、Cout（进位输出）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.05.32@2x.png" alt="CleanShot 2024-03-19 at 02.05.32@2x" style="zoom:30%;" />

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.06.45@2x.png" alt="CleanShot 2024-03-19 at 02.06.45@2x" style="zoom:30%;" />

### 4-bit加法器

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.07.53@2x.png" alt="CleanShot 2024-03-19 at 02.07.53@2x" style="zoom:30%;" />

### 加法运算的实现示例

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.08.12@2x.png" alt="CleanShot 2024-03-19 at 02.08.12@2x" style="zoom:30%;" />

### 检查加法运算结果是否溢出

“溢出”（overflow）

- 运算结果超出了正常的表示范围

“溢出”仅针对有符号数运算

- 两个正数相加，结果为负数
- 两个负数相加，结果为正数

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.09.22@2x.png" alt="CleanShot 2024-03-19 at 02.09.22@2x" style="zoom:30%;" />

### “进位”和“溢出”示例

注意区分“进位"和“溢出”

- 有“溢出”时，不一定有“进位”
- 有“进位”时，不一定有“溢出”

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.12.06@2x.png" alt="CleanShot 2024-03-19 at 02.12.06@2x" style="zoom:50%;" />

溢出：有符号数超出值域，输出错误的数

进位：无符号数超出值域，输出错误的数

### “溢出”的检查方法

“最高位的进位输入”不等于“最高位的进位输出”

其实就是要求符号位不能是错误的

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.34.50@2x.png" alt="CleanShot 2024-03-19 at 02.34.50@2x" style="zoom:30%;" />

### 对“溢出”的处理方式：MIPS

提供两类不同的指令分别处理

（1）将操作数看做有符号数，发生“溢出”时产生异常
• add rd, rs, rt # R[rd]=R[rs]+R[rt]
• addi rt,rs, imm # R[rt]=R[rs] +SignExtImm

（2）将操作数看做无符号数，不处理“溢出”
• addu rd, rs, rt # R[rd]=R[rs]+R[rt]
• addiu rt,rs, imm # R[rt]=R[rs] +SignExt Imm

### 对“溢出”的处理方式：x86

溢出标志OF （Overtlow Flag）
。如果把操作数看做有符号数，运算结果是否发生溢出
。若发生溢出，则自动设置OF=1；否则，OF=0

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.36.52@2x.png" alt="CleanShot 2024-03-19 at 02.36.52@2x" style="zoom:30%;" />

### 减法运算

減减法运算均可转换为加法运算：A -B= A + (-B)

补码表示的二进制数的相反数，转换规则：按位取反，末位加一

在加法器的基础上实现減法器：A + (-B) = A + (~B+1)

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.43.19@2x.png" alt="CleanShot 2024-03-19 at 02.43.19@2x" style="zoom:30%;" />

## 4.6 加法器的优化

### 行波进位加法器（Ripple-Carry Adder, RCA）

结构特点：低位全加器的Cout连接到高一位全加器Cin

优点：电路布局简单，设计方便

缺点：高位的运算必须等待低位的运算完成，延迟时间长

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.44.57@2x.png" alt="CleanShot 2024-03-19 at 02.44.57@2x" style="zoom:30%;" />

### 4-bit RCA的门电路实现

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.45.57@2x.png" alt="CleanShot 2024-03-19 at 02.45.57@2x" style="zoom:30%;" />

### 4-bit RCA的关键路径（延迟最长的路径）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.47.54@2x.png" alt="CleanShot 2024-03-19 at 02.47.54@2x" style="zoom:30%;" />

### 32-bit RCA的性能分析

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.49.32@2x.png" alt="CleanShot 2024-03-19 at 02.49.32@2x" style="zoom:30%;" />

输入输出寄存器想要在一个时钟周期内完成一次32bits加法运算，由于一次32bits加法运算至少需要65个门延迟，最短就是65T=1.3ns，也就是手机主频率受到加法运算限制只有769MHz

### 加法器的优化思路

主要问题：高位的运算必须等待低位的“进位输出信号”

优化思路：能否提前计算出“进位输出信号”？

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.55.11@2x.png" alt="CleanShot 2024-03-19 at 02.55.11@2x" style="zoom:30%;" />

这样做的好处是可以看出G，P都是输入的时候就可以确定的信号

迭代使用这个公式就可以发现每一个C都是可以在输入的时候就确定下来的

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.56.35@2x.png" alt="CleanShot 2024-03-19 at 02.56.35@2x" style="zoom:30%;" />

### 提前计算C4的电路实现

优点：计算Ci+的延迟时间固定为三级门延迟，与加法器的位数无关

缺点：如果进一步拓宽加法器的位数，则电路变得非常复杂

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.58.02@2x.png" alt="CleanShot 2024-03-19 at 02.58.02@2x" style="zoom:30%;" />

### 超前进位加法器（Carry-Lookahead Adder, CLA）

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 02.59.00@2x.png" alt="CleanShot 2024-03-19 at 02.59.00@2x" style="zoom:30%;" />

### 32-bit加法器的实现

如果采用行波进位
。总延迟时间为65级门延迟

如果采用完全的超前进位
。理想的总延迟时间为4级门延迟
。实际上电路过于复杂，难以实现

通常的实现方法
。采用多个小规模的超前进位加法器拼接而成
。例如，用4个8-bit的超前进位加法器连接成32-bit加法器

<img src="./4.算术逻辑单元.assets/CleanShot 2024-03-19 at 03.00.04@2x.png" alt="CleanShot 2024-03-19 at 03.00.04@2x" style="zoom:30%;" />

4级CLA：四个8bits CLA按照行波进位加法器的样子逐个进行，但是前三个CLA只需要3个周期就可以得到最终的进位值，所以总门延迟为: 3+3+3+4=13级门延迟，就是0.26ns