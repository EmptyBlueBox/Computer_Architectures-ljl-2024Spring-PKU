# 第六章 - 单周期处理器

## 6.1 处理器的设计步骤

### MIPS 指令系统的简化版本

![mips_simplified](6.单周期处理器.assets/mips_simplified.png)

指令格式：指令被编码为 32 位的二进制串。

-   R 型指令：用于寄存器之间的运算，分为**六个位域**，包含操作码（opcode）、源寄存器（rs）、目标寄存器（rt）、目的寄存器（rd）、移位量（shamt，保留）和功能码（funct）。
-   I 型指令：用于立即数运算和访问内存，分为**四个位域**，包含操作码（opcode）、源寄存器（rs）、目标寄存器（rt）和立即数（immediate）。

指令的含义：

-   `addu rd,rs,rt`: 无符号加法，将寄存器 rs 和 rt 的值相加，结果存入 rd。
-   `subu rd,rs,rt`: 无符号减法，从寄存器 rs 的值中减去 rt 的值，结果存入 rd。
-   `ori rt,rs,imm16`: 寄存器 rs 的值和立即数 imm16 进行逻辑或（OR）操作，结果存入 rt。
-   `lw rt,imm16(rs)`: 从内存地址（寄存器 rs 的值加上立即数 imm16）加载字到寄存器 rt。
-   `sw rt,imm16(rs)`: 将寄存器 rt 的值存储到内存地址（寄存器 rs 的值加上立即数 imm16）。
-   `beq rs,rt,imm16`: 分支等于（branch on equal），如果寄存器 rs 和 rt 的值相等，则跳转到当前地址加上立即数 imm16 指定的位置。

### 指令位域的分解

![instruction_bit_decomposition](6.单周期处理器.assets/instruction_bit_decomposition.png)

-   R 指令需求：存放指令的存储器，可读， 地址和数据均为 32 位
-   I 指令需求：存放指令地址的 32 位寄存器

### 指令的操作

- `ADDU`：无符号加法，结果存储在目的寄存器`rd`中。

  指令格式：`ADDU R[rd] ← R[rs] + R[rt]; PC ← PC+4`

- `SUBU`：无符号减法，结果存储在目的寄存器`rd`中。

  指令格式：`SUBU R[rd] ← R[rs] - R[rt]; PC ← PC+4`

- `ORI`：寄存器`rs`的内容与立即数`Imm16`进行逻辑或操作，结果存储在寄存器`rt`中。

  指令格式：`ORI R[rt] ← R[rs] | zero_ext(Imm16); PC ← PC+4`

由此得出，我们需要的运算器需要支持的操作数包括：

-   两个寄存器
-   一个寄存器和一个扩展后的立即数

### 指令的操作

- `LOAD`：从内存中加载数据到寄存器`rt`。

  指令格式：`LOAD R[rt] ← MEM[R[rs]+sign_ext(Imm16)]; PC ← PC+4`

- `STORE`：将寄存器`rt`的数据存储到内存地址。

  指令格式：`STORE MEM[R[rs]+sign_ext(Imm16)] ← R[rt]; PC ← PC+4`

- `BEQ`：如果寄存器`rs`和`rt`的值相等，则跳转到指定的地址。

  指令格式：`BEQ if (R[rs]==R[rt]) then PC ← PC+4 + (sign_ext(Imm16)<<2) else PC ← PC+4`

由此得出，我们需要的运算器需要支持的操作数包括：

-   两个寄存器并比较它们的值
-   一个寄存器和一个扩展后的立即数进行地址计算

需求：

-   存放数据的存储器，可读写，地址和数据均为 32 位
-   16 位立即数符号扩展为 32 位
-   比较两个数，判断是否相等
-   PC 寄存器支持两种自增方式，加 4 或加一个立即数

### 总结

1. 算术逻辑单元（ALU）

   - <img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.25.22@2x.png" alt="CleanShot 2024-04-10 at 08.25.22@2x" style="zoom:50%;" />

   - 运算类型：加、减、或、比较相等

   - 操作数：2个32位的数，来自寄存器或扩展后的立即数

2. 立即数扩展部件

   - <img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.25.39@2x.png" alt="CleanShot 2024-04-10 at 08.25.39@2x" style="zoom:50%;" />

   - 将一个16立即数扩展为32位数

   - 扩展方式：零扩展、符号扩展

3. 程序计数器（PC）

   - <img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.25.47@2x.png" alt="CleanShot 2024-04-10 at 08.25.47@2x" style="zoom:50%;" />

   - 一个32位的寄存器

   - 支持两种加法：加4或加一个立即数

4. 寄存器堆

   - <img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.28.24@2x.png" alt="CleanShot 2024-04-10 at 08.28.24@2x" style="zoom:50%;" />

   - 每个寄存器为32位宽，共32个
   - 支持读操作：rs和rt
   - 支持写操作：rt或rd
   - 注：这称为“两读一写”的寄存器堆

5. 存储器

   - <img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.32.09@2x.png" alt="CleanShot 2024-04-10 at 08.32.09@2x" style="zoom:50%;" />

   - 一个只读的指令存储器，地址和数据均为32位
   - 一个可读写的数据存储器，地址和数据均为32位
   - 注：这两个存储器实际对应了CPU中的指令和数据高速缓存（Cache）



### 存储组件：寄存器堆

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.28.24@2x.png" alt="CleanShot 2024-04-10 at 08.28.24@2x" style="zoom:50%;" />

内部构成：32个32位的寄存器

数据接口信号：

- busA,busB：两组32位的数据输出
- busW ：一组32位的数据输入

读写控制：

- Ra（5位）：选中对应编号的寄存器，将其内容放到busA
- Rb（5位）：选中对应编号的寄存器，将其内容放到busB
- Rw（5位）：选中对应编号的寄存器，在时钟信号（clk）的上升沿，如果写使能信号有效（WriteEnable==1），将busW的内容存入该寄存器
- 注：寄存器堆的读操作不受时钟控制

### 存储组件：存储器

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 08.32.09@2x.png" alt="CleanShot 2024-04-10 at 08.32.09@2x" style="zoom:50%;" />

数据接口信号：

- Data In:32位的数据输入信号
- Data Out:32位的数据输出信号

读写控制：

- Address:32位的地址信号。该信号指定一个存储单元，将其内容送到数据输出信号
- Write Enable：写使能信号。在时钟信号（clk）的上升沿，如果写使能信号有效（为1），将数据输入信号的内容存入地址信号指定存储单元
- 注：存储器读操作不受时钟控制

## 6.2 数据通路的建立

### 建立数据通路的方法

基本原则：根据指令需求，连接组件，建立数据通路

指令的需求：

- 所有指令的共同需求
- 不同指令的不同需求

### 所有指令的共同需求

Instruction Fetch Unit, IFU：

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 18.39.26@2x.png" alt="CleanShot 2024-04-10 at 18.39.26@2x" style="zoom:50%;" />

取指令

- 程序计数器（PC）的内容是指令的地址
- 用PC的内容作为地址，访问指令存储器获得指令编码

更新程序计数器（PC）

- 顺序执行时：PC <- PC + 4
- 发生分支时：PC <- 分支目标的地址

### 不同指令的不同需求

#### 加法和减法指令的需求

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 18.53.24@2x.png" alt="CleanShot 2024-04-10 at 18.53.24@2x" style="zoom:50%;" />

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 18.54.26@2x.png" alt="CleanShot 2024-04-10 at 18.54.26@2x" style="zoom:50%;" />

注：ALUCtr和RegWr是由指令译码生成的控制信号

#### 逻辑运算指令的需求

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 18.56.10@2x.png" alt="CleanShot 2024-04-10 at 18.56.10@2x" style="zoom:50%;" />

问题1：目的寄存器是rt而非rd
问题2：立即数是ALU的输入
问题3：立即数只有16位

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 18.56.46@2x.png" alt="CleanShot 2024-04-10 at 18.56.46@2x" style="zoom:50%;" />



解决方案：增加两个多选器，增加一个婆扩展部件运算指令的控制信号

#### 访存指令的需求（Load）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.00.17@2x.png" alt="CleanShot 2024-04-10 at 19.00.17@2x" style="zoom:50%;" />

问题1：如何进行符号扩展？
问题2：从何处装载数据？

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.00.45@2x.png" alt="CleanShot 2024-04-10 at 19.00.45@2x" style="zoom:50%;" />

解决方案：将原有的零扩展部件增加符号扩展功能：加入数据存储器和多选器。

#### 访存指令的需求（Store）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.01.34@2x.png" alt="CleanShot 2024-04-10 at 19.01.34@2x" style="zoom:50%;" />

问题：不知道什么时候储存

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.01.41@2x.png" alt="CleanShot 2024-04-10 at 19.01.41@2x" style="zoom:50%;" />

解决方案：加入一个控制是否写入的信号

## 6.3 运算指令的控制信号

### 加法指令的操作步骤

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.11.32@2x.png" alt="CleanShot 2024-04-10 at 19.11.32@2x" style="zoom:50%;" />

addu ra, rs, rt
MEM [ PC] 从指令存储器中取回指令
R[rd]=R[rs]+R[rt] 指令指定的操作
PC=PC + 4 计算下一条指令的地址

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.41.36@2x.png" alt="CleanShot 2024-04-10 at 19.41.36@2x" style="zoom:50%;" />

#### 加法指令的操作步骤（1）

Instruction = MEM[PC]
。从指令存储器中取回指令
。所有指令均有此步骤

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.42.50@2x.png" alt="CleanShot 2024-04-10 at 19.42.50@2x" style="zoom:50%;" />

#### 加法指令的操作步骤（2）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.55.30@2x.png" alt="CleanShot 2024-04-10 at 19.55.30@2x" style="zoom:50%;" />

然后计算出来busW之后，在⏰上升沿就会写入到rd中

#### 加法指令的操作步骤（3）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.58.19@2x.png" alt="CleanShot 2024-04-10 at 19.58.19@2x" style="zoom:50%;" />

### ori指令的操作步骤

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 19.59.05@2x.png" alt="CleanShot 2024-04-10 at 19.59.05@2x" style="zoom:50%;" />

ori rt, rS， rs, imml6
МЕМ [PC] 从指令存储器中取回指令
R［rt］=R［rs］ I ZeroExt (imm16] 指令指定的操作
PC=PC + 4 计算下一条指令的地址

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.04.14@2x.png" alt="CleanShot 2024-04-10 at 20.04.14@2x" style="zoom:50%;" />

#### ori指令的操作步骤（2）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.06.50@2x.png" alt="CleanShot 2024-04-10 at 20.06.50@2x" style="zoom:50%;" />

## 6.4 访存指令的控制信号

### lw指令的操作步骤

Iw rt, imm(rs)
① MEM［PC］ 从指令存储器中取回指令
② R[rt］=DataMemory｛R［rs］+SignExt ［imm16］｝指令指定的操作
③ PC=PC + 4 计算下一条指令的地址

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.22.59@2x.png" alt="CleanShot 2024-04-10 at 20.22.59@2x" style="zoom:50%;" />

#### Iw指令的操作步骤（2）

R[rt]=Data Memory(R[rs)+SignExt [imm16]}

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.26.09@2x.png" alt="CleanShot 2024-04-10 at 20.26.09@2x" style="zoom:50%;" />

### SW指令的操作步骤

sw rt, imm(rs)
① MEM［PC］ 从指令存储器中取回指令
② DataMemory ｛R［rs］+SignExt ［ imm16]）=R［rt］ 指令指定的操作
③ PC=PC+4 计算下一条指令的地址

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.28.20@2x.png" alt="CleanShot 2024-04-10 at 20.28.20@2x" style="zoom:50%;" />

#### sW指令的操作步骤（2）

DataMemory(R[rs]+SignExt [imm16]}=R[rt]

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.29.51@2x.png" alt="CleanShot 2024-04-10 at 20.29.51@2x" style="zoom:50%;" />

## 6.5 分支指令的控制信号

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.30.38@2x.png" alt="CleanShot 2024-04-10 at 20.30.38@2x" style="zoom:50%;" />

### 条件分支指令的示例

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.31.27@2x.png" alt="CleanShot 2024-04-10 at 20.31.27@2x" style="zoom:50%;" />

### beq指令的操作步骤

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.35.22@2x.png" alt="CleanShot 2024-04-10 at 20.35.22@2x" style="zoom:50%;" />

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.35.36@2x.png" alt="CleanShot 2024-04-10 at 20.35.36@2x" style="zoom:50%;" />

#### beq指令的操作步骤（2）

if (R[rs)-R[rt]==0) then zero=1; else zero=0

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.40.35@2x.png" alt="CleanShot 2024-04-10 at 20.40.35@2x" style="zoom:50%;" />

#### beq指令的操作步骤（3）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.42.57@2x.png" alt="CleanShot 2024-04-10 at 20.42.57@2x" style="zoom:50%;" />

## 6.6 控制信号的集成

### 现有指令所需的控制信号

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.45.39@2x.png" alt="CleanShot 2024-04-10 at 20.45.39@2x" style="zoom:50%;" />

### 控制逻辑与数据通路

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.46.28@2x.png" alt="CleanShot 2024-04-10 at 20.46.28@2x" style="zoom:50%;" />

### 控制信号的汇总（以add指令为例）

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.47.46@2x.png" alt="CleanShot 2024-04-10 at 20.47.46@2x" style="zoom:50%;" />

### 控制信号的逻辑表达式

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.48.06@2x.png" alt="CleanShot 2024-04-10 at 20.48.06@2x" style="zoom:50%;" />

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.49.37@2x.png" alt="CleanShot 2024-04-10 at 20.49.37@2x" style="zoom:50%;" />

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.52.16@2x.png" alt="CleanShot 2024-04-10 at 20.52.16@2x" style="zoom:50%;" />

### 控制器的实现示意图

<img src="./6.单周期处理器.assets/CleanShot 2024-04-10 at 20.52.48@2x.png" alt="CleanShot 2024-04-10 at 20.52.48@2x" style="zoom:50%;" />

