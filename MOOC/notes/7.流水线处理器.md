# 流水线处理器

## 7.1 流水线的基本原理

![pipeline_sketch](7.流水线处理器.assets/pipeline_sketch.png)

采用流水线：

-   流水线填满之后，可以做到每 1 分钟上一道菜：性能提升到原先的 4 倍
-   单独一道菜仍然需要 4 分钟

### MIPS 的主要步骤

![MIPS_steps](7.流水线处理器.assets/MIPS_steps.png)

对 MIPS 处理器亦进行阶段划分：

![MIPS_stages](7.流水线处理器.assets/MIPS_stages.png)

虽然分组了，但是所有的信号都需要在每个阶段中保持稳定。为了充分利用硬件，我们添加寄存器：

![pipeline_regs](7.流水线处理器.assets/pipeline_regs.png)

### 流水线处理器性能分析

![pipeline_perf_analysis](7.流水线处理器.assets/pipeline_perf_analysis.png)

时钟周期：流水线处理器的时钟周期是流水线中 **最慢的阶段的时钟周期**

这是没带上流水线寄存器的，带上之后：

![pipeline_perf_with_reg](7.流水线处理器.assets/pipeline_perf_with_reg.png)

### 总结

流水线中的各个处理部件可 **并行工作**，从而可使 **整个程序** 的执行时间缩短

流水线并 **不会缩短单条指令的执行时间** （甚至由于流水线寄存器的存在，会增加时间） ，而是 **提高了指令的吞吐率**

## 7.2 流水线的优化

### 流水线的调整

不平衡的流水线：每个阶段花费时间不相等的流水线，对单一条指令执行时间和整个处理器的吞吐率都不好。

因此，需要尽可能的平衡各个阶段的时间。为此可能要更细地切分阶段，使之变为平衡的流水线。

![super_pipeline](7.流水线处理器.assets/super_pipeline.png)

**“超级流水线” 技术 (Super Pipelining)**：将流水线细分为更多的阶段，增加流水线的深度提升时钟频率，从而 **提高指令吞吐率**

但是流水线的级数不是越多越好，因为有流水线寄存器的存在，所以更深的级数会导致单条指令的延迟越来越大，流水线寄存器延迟所占比例也越来越大，填满一条流水线所需的指令也会增加。

x86 被 RISC 追赶，所以做出了改进：在流水线内部用硬件把复杂的 x86 指令划分为更细的 RISC 指令，从而既可以使用先进的 RISC 技术（流水线等），也可以保证对原先的 x86 程序的兼容。

2004，Pemtium 4 (Prescott) 达到了 31 级（最高）。

现在我们已经很难简单的通过增加流水线的深度来获得性能上的提升了。

## 7.3 超标量流水线

超标量（Superscalar）：通常，具有两条或两条以上 **并行工作** 的流水线结构称为 **超标量结构**

-   亦称为 “超标量流水线” 或直接称为 “超标量”。
-   与之相对，之前的流水线则称为 “标量流水线”

使用超标量结构的处理器称为 **超标量处理器**

几条流水线就称为几发射。

### Pentium 的超标量流水线（第一款超标量 x86 CPU）

双发射，5 级流水线

-   两条流水线：“U 流水” 和 “V 流水”
-   共用取值、译码阶段
-   每条流水线都拥有自己的地址生成逻辑、ALU 及数据 Cache 接口
-   在一个时钟周期内，可以 **同时发送两条指令**

![pentium](7.流水线处理器.assets/pentium.png)

CDC6000：通常认为是最早采用超标量技术的计算机，有 10 个并行功能部件，不过没有流水线。by 西摩・克雷

### Core i7 的超标量流水线

由于长度变长，需要先进行指令的识别。

**超标量（Superscalar）**

-   通常，具有两条或两条以上并行工作的流水线结构称为超标量结构亦称为 “超标量流水线” 或直接称为 “超标量”

    -   与之相对，之前的流水线则称为 “标量流水线”
    -   使用超标量结构的处理器称为超标量处理器

-   标量流水线和超标量流水线

    -   单周期 → 标量流水线：**时间并行性** 的优化，主要是对现有硬件的切分。
    -   标量流水线 → 超标量流水线：**空间并行性** 的优化，需成倍增加硬件资源

### 超标量流水线与多核 CPU

现代的多核 CPU 通常是在一个 CPU 芯片中集成了多个超标量处理器核

![core_i7](7.流水线处理器.assets/core_i7.png)

这是 4 核的处理器。

## 7.4 流水线冒险

冒险：阻止下一条指令在下一个时钟周期开始执行的情况

-   **结构冒险**：所需的硬件部件正在为之前的指令工作。
-   **数据冒险**：需要等待之前的指令完成数据的读写。
-   **控制冒险**：需要根据之前指令的结果决定下一步的行为。

### 结构冒险

![struct_hazard](7.流水线处理器.assets/struct_hazard.png)

问题来源：如果指令和数据放在同一个存储器中，则不能同时读存储器

解决方案 1：流水线停顿（stall），产生空泡（bubble），这是安全且简便的方法，但是会严重影响效率。

解决方案 2：指令和数据放在不同的存储器中（更本质的解决问题）

![struct_hazard_2](7.流水线处理器.assets/struct_hazard_2.png)

问题来源：读寄存器和写寄存器同时发生

解决方案：前半个时钟周期写，后半个时钟周期读，并且设置独立的读写口（错开）

## 数据冒险

![data_hazard](7.流水线处理器.assets/data_hazard.png)

问题来源：一条指令（add）需要使用之前指令（sub）的运算结果，但是结果还没有写回

临时解决方案：流水线停顿（stall），产生空泡（bubble）

## 控制冒险

![control_hazard](7.流水线处理器.assets/control_hazard.png)

问题来源：尚未确定是否发生分支，如何进行下一次取指？

临时解决方案：流水线停顿 (stall)，产生空泡 (bubble)

## 7.5 数据冒险的处理

![data_hazard_solution_nop](7.流水线处理器.assets/data_hazard_solution_nop.png)

软件解决方案：插入一条 `nop` 指令，也即什么都不做，等待数据准备好。

但是这样并不能很好适配流水线架构更新的情况。当流水线级数增加，等待的周期数也需要同时增加。

硬件解决方案 1：执行流水线停顿（stall），产生空泡（bubble）。

检测数据冒险的方法：对比在 **译码阶段获得的需要读的寄存器的编号** 与后面各个阶段正在执行的指令是否要写某个寄存器，以及 **要写哪个寄存器**。

时间角度重新看这条指令，在 `sub` 指令执行完 ALU 计算后，其实已经可以开始执行 `add` 指令了，只是由于数据还没有写回，所以不能执行。

因此，我们得到：

硬件解决方案 2：数据前递（Forwarding） / 旁路（Bypass）

思想：把执行阶段的结果直接提前传递给需要的阶段，而不是等待写回阶段。

![forwarding](7.流水线处理器.assets/forwarding.png)

相当于绕过了寄存器堆，直接从执行阶段传递给需要的阶段。

### Load-Use 数据冒险

定义：一条指令需要使用之前指令的访存结果 (Load-Use Harzard) 。

此时，**数据前递 (Forwarding) 也无法解决**

这是因为 Load 必须在访存结束后才能得到结果，所以我们无法跨越时间提前传递数据。

因而，我们回退到之前的解决方法：流水线停顿（stall）+ 数据前递

这个解决方案没有让流水线获得最高的指令吞吐率，但是保证指令执行正确才是我们的首要目标。

## 7.6 控制冒险的处理

![control_hazard_improve](7.流水线处理器.assets/control_hazard_improve.png)

转移指令：改变指令流向，破坏流水模式

转移指令经常带来控制冒险，造成性能损失。因此，我们需要尽量减少转移指令的影响。

$$
\text{Pipeline stall cycles from branches} = \text{Branch Frequency} \times \text{Branch Penalty}
$$

当执行了转移指令，并确实发生转移时，产生如下的开销，称为 “转移开销”

1. 将按顺序预取的指令废除（即 “排空流水线”）
2. 从转移目标地址重新取指令

转移开销的构成：

1. “要不要转移？”：转移条件判定引起的开销
2. “转移到哪里？”：生成目标地址引起的开销

### 转移指令的分类

![transfer_inst_classification](7.流水线处理器.assets/transfer_inst_classification.png)

#### 无条件转移

**直接转移**

```asm
j target
```

![jr_target](7.流水线处理器.assets/jr_target.png)

所需信息在取指阶段即可获得 （流水线不停顿）

**间接转移**

```asm
jr $rs
```

![jr_rs](7.流水线处理器.assets/jr_rs.png)

译码阶段才能获得转移目标地址（流水线停顿 1 周期）

#### 条件转移

**直接转移**

```asm
beq $rs, $rt, imm16
```

![beq](7.流水线处理器.assets/beq.png)

比较指令较为简单，不需要用到 ALU，直接在 busA busB **连接一个额外的比较电路**，这个电路是很简单的，速度也很快，不至于影响整个译码阶段的时间。

![beq_2](7.流水线处理器.assets/beq_2.png)

### 控制冒险的影响

![control_hazard_affect](7.流水线处理器.assets/control_hazard_affect.png)

-   无条件直接转移：`j Target`，流水线无停顿
-   无条件间接转移：`jr rs`，流水线停顿 1 个周期
-   条件转移：`beq rs，rt，imm16`，流水线停顿 1 个周期

### 延迟转移技术

经过我们的改进之后，无条件的直接转移可以让流水线不停顿。

而无条件的间接转移以及条件转移都不得不让流水线停顿一个周期，才能消除控制冒险的影响。

通过改变指令的执行顺序，我们可以让流水线不停顿：

![delayed_transfer](7.流水线处理器.assets/delayed_transfer.png)
